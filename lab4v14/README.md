# Лабораторна робота №4

**Тема:** Абстракції та інтерфейси. Композиція та агрегація.

**Мета:** навчитися створювати абстрактні класи та інтерфейси, будувати ієрархії класів із використанням композиції та агрегації, реалізовувати прості обчислення, демонструвати гнучкість і повторне використання коду.

---

## Опис виконання завдання

Під час виконання роботи було створено ієрархію класів для моделювання автомобілів.

1.  **Інтерфейс `IVehicle`**: Оголошує "контракт", якому мають відповідати всі транспортні засоби. Він вимагає наявності властивості `ConsumptionPer100Km` та методів `StartEngine()` і `Drive()`.

2.  **Абстрактний клас `AbstractVehicle`**: Реалізує інтерфейс `IVehicle`. Він надає спільне поле `_engine` та реалізацію методу `StartEngine()`. Метод `Drive()` оголошено абстрактним, що змушує класи-наслідники надати власну реалізацію.

3.  **Композиція**: Зв'язок "has-a" реалізовано між `AbstractVehicle` та `Engine`. Класи `Truck` та `Bus`, наслідуючись від `AbstractVehicle`, створюють власні екземпляри `Engine` у своїх конструкторах. Життєвий цикл `Engine` повністю контролюється автомобілем, що є ознакою **композиції**.

4.  **Конкретні реалізації (`Truck`, `Bus`)**: Два класи, що наслідують `AbstractVehicle`. `Truck` додатково реалізує логіку коригування споживання пального залежно від ваги вантажу. Обидва класи реалізують обов'язковий метод `Drive()`.

5.  **Агрегація та Обчислення**: Створено окремий клас `TripCalculator`. Він приймає в конструкторі об'єкт типу `IVehicle` (це **агрегація**, оскільки `TripCalculator` не володіє об'єктом `IVehicle`, а лише використовує його). Цей клас реалізує **обчислення** вартості поїздки (`CalculateTripCost`) на основі відстані, ціни пального та середнього споживання, яке він отримує від об'єкта `IVehicle`.

---

## Приклади запуску (скріншоти виводу програми)

Ось текстовий вивід роботи консольної програми:
--- Демонстрація Лабораторної роботи №4 ---

--- Створення Вантажівки (Truck) --- [Engine] Створено двигун типу: Diesel V8

--- Створення Автобуса (Bus) --- [Engine] Створено двигун типу: Diesel V6

--- Дії Вантажівки --- [Engine] Двигун Diesel V8 запущено. Врррум! [Truck] Вантажівка їде 150 км з вантажем 5000 кг. Середнє споживання вантажівки (з вантажем): 35.00 л/100км

--- Дії Автобуса --- [Engine] Двигун Diesel V6 запущено. Врррум! [Bus] Автобус їде 150 км з 40 пасажирами. Середнє споживання автобуса: 20.00 л/100км

--- Розрахунок поїздок (Агрегація) --- Вартість поїздки 250 км для Вантажівки: 4 856,25 ₴ Вартість поїздки 250 км для Автобуса: 2 775,00 ₴
*(Сюди можна вставити реальний скріншот вашої консолі з цим виводом)*

### 3. Відповіді на контрольні запитання

**1. У чому різниця між абстрактним класом і інтерфейсом?**

* **Інтерфейс** (Interface):
    * Це повний **контракт**. Він лише *оголошує* методи та властивості, але (зазвичай) не надає їм реалізації.
    * Клас може **реалізовувати** (implement) *багато* інтерфейсів.
    * Не може містити полів (стану) або конструкторів.
    * Відповідає на питання: "**Що** об'єкт повинен вміти робити?"

* **Абстрактний клас** (Abstract Class):
    * Це **базовий клас** (шаблон). Він може містити *як абстрактні* (без реалізації), так і *звичайні* (з реалізацією) методи, а також поля (стан) і конструктори.
    * Клас може **наслідувати** (inherit/extend) *лише один* абстрактний (або будь-який) клас.
    * Відповідає на питання: "**Чим** об'єкт є?" і надає спільну функціональність.

**2. Коли краще використовувати композицію, а коли наслідування?**

* **Наслідування (Inheritance - "Is-A" / "Є")**: Використовуйте, коли один клас є *специфічним різновидом* іншого.
    * *Приклад:* `Вантажівка` **є** `ТранспортнийЗасіб`. `Автобус` **є** `ТранспортнийЗасіб`.
    * Це сильний зв'язок, який використовується для поліморфізму (роботи з різними типами через спільний базовий клас).

* **Композиція (Composition - "Has-A" / "Має")**: Використовуйте, коли один клас *складається з* іншого або *має* інший об'єкт як частину свого стану.
    * *Приклад:* `Автомобіль` **має** `Двигун`.
    * Це гнучкіший підхід. Загальне правило ООП: **"Надавайте перевагу композиції над наслідуванням"** (Favor composition over inheritance), оскільки вона дозволяє змінювати поведінку під час виконання і не створює жорстких ієрархій.

**3. Як працює агрегація та чим вона відрізняється від композиції?**

І композиція, і агрегація є типами асоціації "Has-A" ("Має"). Різниця полягає в **силі зв'язку** та **управлінні життєвим циклом**:

* **Композиція (Composition):**
    * **Сильний зв'язок "володіння"**.
    * "Частина" (наприклад, `Двигун`) **не може існувати** без "цілого" (наприклад, `Автомобіль`).
    * "Ціле" **створює** і **знищує** "частину". Якщо ви знищите автомобіль, двигун буде знищено разом з ним.
    * *У нашому коді:* `Truck` створює `new Engine()` у своєму конструкторі.

* **Агрегація (Aggregation):**
    * **Слабкий зв'язок "використання"**.
    * "Частина" (наприклад, `IVehicle`) **може існувати** окремо від "цілого" (наприклад, `TripCalculator`).
    * "Ціле" лише *використовує* "частину", але не керує її життєвим циклом.
    * *У нашому коді:* `TripCalculator` отримує `IVehicle` через конструктор. Якщо `TripCalculator` буде знищено, `IVehicle` (вантажівка чи автобус) продовжить існувати.

**4. Чи може клас реалізовувати кілька інтерфейсів одночасно?**

**Так.** Це одна з ключових переваг інтерфейсів. Клас у C# (та багатьох інших мовах) може наслідувати лише один базовий клас, але може реалізовувати скільки завгодно інтерфейсів.

*Приклад:* `class FlyingCar : Vehicle, IFlyable, IDriveable` (Клас `FlyingCar` наслідує `Vehicle` і реалізує контракти `IFlyable` та `IDriveable`).

**5. Для чого в ООП використовують інтерфейси як контракти?**

Інтерфейс як "контракт" — це **обіцянка**, яку дає клас. Якщо клас реалізує інтерфейс `IVehicle`, він *гарантує* кожному, хто його використовує, що він має методи `StartEngine()` і `Drive()`.

Це дозволяє досягти **слабкої зв'язності (Loose Coupling)**:
Наш `TripCalculator` не знає *нічого* про `Truck` чи `Bus`. Йому байдуже, чи є там пасажири, чи вантаж. Він працює *лише* з контрактом `IVehicle` (йому потрібне лише значення `ConsumptionPer100Km`). Це означає, що завтра ми можемо додати клас `Motorcycle`, реалізувати в ньому `IVehicle`, і `TripCalculator` зможе працювати з ним без будь-яких змін у своєму коді.