Доповідь: Анти-патерн "God Object" та принцип SRP
У професійній розробці архітектура системи оцінюється за тим, наскільки легко її змінювати. Анти-патерн God Object (Об'єкт-Бог) є одним із головних бар'єрів на шляху до гнучкого коду, оскільки він прямо суперечить фундаментальному принципу Single Responsibility Principle (Принцип єдиної відповідальності).

1. Характеристики "God Object"
God Object — це об'єкт, який акумулює в собі занадто багато функціональних обов'язків, стаючи центральним вузлом усієї логіки програми.

Надмірна поінформованість: Клас знає деталі реалізації багатьох інших компонентів (робота з мережею, збереження даних, валідація, UI).

Висока концентрація логіки: Замість того, щоб делегувати завдання дрібним об'єктам, він виконує їх самостійно.

Ефект "спагеті": Через велику кількість методів і полів усередині одного класу виникають приховані залежності, що робить кожну зміну ризикованою.

Труднощі перевикористання: Такий об'єкт неможливо перенести в інший проєкт, не потягнувши за собою всю систему.

2. Порушення принципу SRP
Принцип SRP (Single Responsibility Principle) стверджує, що кожен клас повинен мати лише одну причину для зміни.

Об'єкт порушує цей принцип, якщо він намагається одночасно бути:

Диспетчером даних (збереження та отримання).

Обробником логіки (бізнес-правила).

Форматувальником (підготовка даних для виводу).

Коли ці ролі змішуються, будь-яка зміна у вимогах до бази даних змушує нас редагувати той самий файл, де лежить бізнес-логіка. Це збільшує ймовірність появи багів у непов'язаних частинах системи.

3. Рефакторинг та стратегія виправлення
Щоб позбутися "Об'єкта-Бога" та привести систему до відповідності SRP, застосовується метод декомпозиції:

Виділення відповідальностей: Аналізуються всі методи класу та групуються за призначенням.

Створення сервісів та делегування: Замість того, щоб виконувати дію самостійно, головний об'єкт має звертатися до спеціалізованих класів (наприклад, DatabaseService, NotificationService, Logger).

Використання інтерфейсів: Це дозволяє відокремити "що робити" від "як робити", роблячи систему модульною.

Інкапсуляція логіки: Дані мають оброблятися там, де вони зберігаються, або через чітко визначені контракти, уникаючи створення одного "всезнаючого" контролера.