## Контрольні питання та відповіді

### 1. Які типи винятків найчастіше виникають при роботі з файлами та мережею?
**При роботі з файлами (System.IO):**
* `FileNotFoundException`: Спроба доступу до файлу, якого не існує.
* `DirectoryNotFoundException`: Спроба доступу до неіснуючої папки.
* `IOException`: Загальна помилка вводу-виводу (наприклад, файл зайнятий іншим процесом).
* `UnauthorizedAccessException`: Немає прав доступу до файлу (тільки читання, системний файл тощо).

**При роботі з мережею (System.Net.Http):**
* `HttpRequestException`: Помилка при виконанні HTTP-запиту (наприклад, сервер повернув 404 або 500, DNS не знайдено).
* `SocketException`: Проблеми на рівні TCP-сокетів (розрив з'єднання, порт недоступний).
* `TaskCanceledException` (або `TimeoutException`): Час очікування відповіді від сервера минув.

### 2. Поясніть принцип роботи патерну Retry. Коли його доцільно використовувати?
**Принцип:**
Патерн Retry полягає в автоматичному повторному виконанні операції, яка завершилася невдачею, через певний проміжок часу.

**Коли використовувати:**
Його доцільно використовувати для **тимчасових (transient)** помилок — тобто таких, які можуть зникнути самі по собі через короткий час.
* *Приклади:* короткочасна втрата мережі, перевантаження сервера (Timeouts), блокування файлу іншим процесом ("file in use").
* *Не варто використовувати:* для фатальних помилок (невірний пароль, файл видалено назавжди, помилка в коді).

### 3. Як реалізувати експоненційну затримку між повторними спробами?
Експоненційна затримка означає, що час очікування збільшується в геометричній прогресії з кожною невдачею, щоб зменшити навантаження на систему, яка і так "хворіє".

**Формула:**
$$Delay = InitialDelay \times 2^{AttemptNumber}$$

**Приклад:**
1. Спроба 1 (невдача) -> Чекаємо 1 сек.
2. Спроба 2 (невдача) -> Чекаємо 2 сек.
3. Спроба 3 (невдача) -> Чекаємо 4 сек.

### 4. Для чого потрібен делегат `shouldRetry` у допоміжному класі `RetryHelper`?
Делегат `shouldRetry` (типу `Func<Exception, bool>`) дозволяє фільтрувати помилки. Він вирішує, чи має сенс повторювати операцію при конкретному типі винятку.

Без цього механізму ми могли б нескінченно повторювати спроби для помилок, які ніколи не виправляться самі (наприклад, `ArgumentNullException` або `AccessDenied`), що лише витрачає ресурси програми.